#!/usr/bin/perl

use warnings;
use strict;
use Config::General;
use Data::Dumper;
use POE qw(Wheel::Run Filter::Reference Wheel::FollowTail);

# requirements :  libpoe-perl, libconfig-general-perl, libio-pty-perl

my $conf = Config::General->new(
         -ConfigFile => "../../../etc/suicideCrypt/suicideCryptd.conf",
);
my %configH = $conf->getall;
my @logsToWatch;
# my %drives;
my %alerts;
my @systemUsers = getSystemUsers();
my @allowedUsers = getAllowedUsers();

# Tail the Logs we care about for responses.
POE::Session->create(
  inline_states => {
    _start => \&begin_watchers,
    # Handle records from each log differently.
    ossec_record  => \&ossec_got_record,
    auth_record  => \&auth_got_record,
    # Handle log resets and errors the same way for each file.
    log_reset => \&generic_log_reset,
    log_error => \&generic_log_error,
  }
);


# Monitor UDEV for UDEV events
# change to generic system event monitor mirroring above that can be handed system demons to call. 
POE::Session->create(
    inline_states => {
        _start           => \&on_start,
        got_child_stdout => \&on_child_stdout,
        got_child_stderr => \&on_child_stderr,
        got_child_close  => \&on_child_close,
        got_child_signal => \&on_child_signal,
        read_from_stdin => \&read_from_stdin,
    }
);

# POE session to run round looking for alerts.
POE::Session->create(
  inline_states => {
    _start => sub {
      $_[KERNEL]->alias_set('FetishWatchdog');
      $_[HEAP]->{next_alarm_time} = int(time()) + 2;
      $_[KERNEL]->alarm(tick => $_[HEAP]->{next_alarm_time});
    },
    tick => sub {
      my $key;
      my $name;

      foreach $key (keys %alerts) {
        if ($alerts{$key}{alert}) {
          # Do all the magic bits!
        }
      }
      $_[HEAP]->{next_alarm_time} = $_[HEAP]->{next_alarm_time} + 2;
      $_[KERNEL]->alarm(tick => $_[HEAP]->{next_alarm_time});
    },
  },
);



$poe_kernel->run();
exit 0;

#### Subs below here. 

sub begin_watchers {
  my $heap = $_[HEAP];
  my $key;
  my $service;
  my $log_file;
  my $log_watcher;

  foreach $key (keys(% {$configH{logs}} )) {
    unless ($configH{logs}{$key}{enabled}) {
	next;
    }
    $service = $key;
    $alerts{$service}{alert} = 0;
    $log_file = $configH{logs}{$key}{location};
    print "Starting a log processs for $key!\n";
    print "Watching : $log_file\n";
    $log_watcher = POE::Wheel::FollowTail->new(
	Filename   => $log_file,
	InputEvent => $service . "_record",
	ResetEvent => "log_reset",
	 ErrorEvent => "log_error",
    );
    $heap->{services}->{$log_watcher->ID} = $service;
    $heap->{watchers}->{$log_watcher->ID} = $log_watcher;
  }
}

# Handle log resets the same way for each file.  Simply recognize that
# the log file was reset.
sub generic_log_reset {
  my ($heap, $wheel_id) = @_[HEAP, ARG0];
  my $service = $heap->{services}->{$wheel_id};
  print "--- $service log reset at ", scalar(gmtime), " GMT\n";
}

# Handle log errors the same way for each file.  Recognize that an
# error occurred while watching the file, and shut the watcher down.
# If this were a real log watcher, it would periodically try to resume
# watching the log file.
sub generic_log_error {
  my ($heap, $operation, $errno, $error_string, $wheel_id) =
    @_[HEAP, ARG0, ARG1, ARG2, ARG3];
  my $service = $heap->{services}->{$wheel_id};
  print "--- $service log $operation error $errno: $error_string\n";
  print "--- Shutting down $service log watcher.\n";
  delete $heap->{services}->{$wheel_id};
  delete $heap->{watchers}->{$wheel_id};
}

sub ossec_got_record {
  my $log_record = $_[ARG0];
  my $alertLevel;

  # Ok, we got a new OSSec alert, lets parse for a level of dangerous.
  if ($log_record =~ m/level (\d+)/ ) {
    if ($1 >= 11) {
      print "We got a level of $1!! Immediatly react\n";
    }
  }
  return;
}

sub auth_got_record {
  my $log_record = $_[ARG0];
  my $user; 
  my $okUser;
  my $ok = 0;

  if ($log_record =~ m/session opened for user (\w+) /) {
    $user = $1;
    print "New AuthLog line! For user $user\n";
    if (($log_record =~ m/cron:session/) && ($configH{logs}{auth}{ignorecron})) {
      print "We're allowing this as we're ignoring cron\n"; 
      return 1;
    }
    foreach $okUser (@allowedUsers) {
      if ($okUser eq $user) {
        $ok = 1;
      }
    }
    if ($ok) {
      print "User $user is in the allowed list, moving on\n";
      $ok = 0;
    } else { 
      print "Illegal usr $user logged in! Panic!\n";
      $alerts{auth}{alert} = 1;
    }
  }
  return;
}

sub on_start {
    my $child = POE::Wheel::Run->new(
        Conduit => 'pty-pipe',
        Program     => ["udevadm monitor" ],
        StdoutEvent => "got_child_stdout",
        StderrEvent => "got_child_stderr",
        CloseEvent  => "got_child_close",
    );
    my $name = "udevadm";
    $alerts{$name}{alert} = 0;
    $_[KERNEL]->sig_child($child->PID, "got_child_signal");

    $_[HEAP]{children_by_wid}{$child->ID} = $child;
    $_[HEAP]{children_by_pid}{$child->PID} = $child;
    $_[HEAP]->{job} = $child;

    print("Child pid ", $child->PID, " started as wheel ", $child->ID,
".\n");
}

sub on_child_stdout {
    my ($stdout_line, $wheel_id) = @_[ARG0, ARG1];
    my $child = $_[HEAP]{children_by_wid}{$wheel_id};
    if ($stdout_line =~ m/usb/) {
      if (!($alerts{udevadm}{alert})) {
        $alerts{udevadm}{alert} = 1;
        print "WARNING! USB State change detected\n";
      }
    }
}

sub on_child_close {
    my $wheel_id = $_[ARG0];
    my $child    = delete $_[HEAP]{children_by_wid}{$wheel_id};

    unless (defined $child) {
        print "wid $wheel_id closed all pipes.\n";
        return;
    }

    print "pid ", $child->PID, " closed all pipes.\n";
    delete $_[HEAP]{children_by_pid}{$child->PID};
}

sub on_child_signal {
    print "pid $_[ARG1] exited with status $_[ARG2].\n";
    my $child = delete $_[HEAP]{children_by_pid}{$_[ARG1]};

    # May have been reaped by on_child_close() .
    return unless defined $child;
    delete $_[HEAP]{children_by_wid}{$child->ID};
}

sub getSystemUsers {

  my $fh;
  my @users;
  my @line;
  my $user;
  my $filename = "/etc/passwd";


  open($fh, '<', $filename) or die "Could not open file '$filename' $!";
  while (<$fh>) {
    @line = split(/:/, $_);
    if ($line[2] < 1000)  {
      push @users, $line[0];
    }
  }
  return @users;
}

sub getAllowedUsers {
  my @allowed;

  @allowed = split(/,/, $configH{logs}{auth}{allowedusers});
  if ($configH{logs}{auth}{allowsystemusers}) {
    @allowed = (@allowed, @systemUsers);
  }
  return @allowed;
}


### EOF ###
