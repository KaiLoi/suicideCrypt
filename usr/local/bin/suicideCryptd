#!/usr/bin/perl

use warnings;
use strict;
use Config::General;
use Data::Dumper;
use POE qw(Wheel::Run Filter::Reference Wheel::FollowTail);

# requirements :  libpoe-perl, libconfig-general-perl, libio-pty-perl

my $conf = Config::General->new(
         -ConfigFile => "../../../etc/suicideCrypt/suicideCryptd.conf",
);
my %configH = $conf->getall;
my @logsToWatch;
# my %drives;
my %alerts;
my $ALERTTEMP = 35;
my @systemUsers = getSystemUsers();
my @allowedUsers = getAllowedUsers();

# Tail the Logs we care about for responses.
POE::Session->create(
  inline_states => {
    _start => \&begin_watchers,
    # Handle records from each log differently.
    ossec_record  => \&ossec_got_record,
    auth_record  => \&auth_got_record,
    # Handle log resets and errors the same way for each file.
    log_reset => \&generic_log_reset,
    log_error => \&generic_log_error,
  }
);

# POE session to run round looking for alerts.
POE::Session->create(
  inline_states => {
    _start => sub {
      $_[KERNEL]->alias_set('FetishWatchdog');
      $_[HEAP]->{next_alarm_time} = int(time()) + 2;
      $_[KERNEL]->alarm(tick => $_[HEAP]->{next_alarm_time});
    },
    tick => sub {
      my $key;
      my $name;

#      print Dumper %alerts;
      foreach $key (keys %alerts) {
        if ($alerts{$key}{alert}) {
          print "We have an alert for $key! Do stuffs!\n";
          # reset the alert; 
          $alerts{$key}{alert} = 0;
        }
      }
      $_[HEAP]->{next_alarm_time} = $_[HEAP]->{next_alarm_time} + 2;
      $_[KERNEL]->alarm(tick => $_[HEAP]->{next_alarm_time});
    },
  },
);

# Start a POE session to monitor lm-sensors for temperature events
if ($configH{systemevents}{sensors}{enabled}) {
  print "Starting a sensors session\n";
  POE::Session->create(
    inline_states => {
      _start      => \&startsensors,
      got_child_stdout   => \&got_child_stdout,
      got_child_stderr => \&got_child_stderr,
      got_child_close   => \&got_child_close,
      got_sigchld   => \&got_sigchld,
    }
  );
}

# Start a POE session to monito udevadm for HW additions and removals. 
if ($configH{systemevents}{udevadm}{enabled}) {
  print "Starting a udevadm session\n";
  POE::Session->create(
    inline_states => {
      _start      => \&startudevadm,
      got_child_stdout   => \&got_child_stdout,
      got_child_stderr => \&got_child_stderr,
      got_child_close   => \&got_child_close,
      got_sigchld   => \&got_sigchld,
    }
  );
}

# Start our POE Kernel.
$poe_kernel->run();
exit 0;

#### Subs below here. 

sub begin_watchers {
  my $heap = $_[HEAP];
  my $key;
  my $service;
  my $log_file;
  my $log_watcher;

  foreach $key (keys(% {$configH{logs}} )) {
    unless ($configH{logs}{$key}{enabled}) {
	next;
    }
    $service = $key;
    $alerts{$service}{alert} = 0;
    $log_file = $configH{logs}{$key}{location};
    print "Starting a log watch processs for $key!\n";
    $log_watcher = POE::Wheel::FollowTail->new(
	Filename   => $log_file,
	InputEvent => $service . "_record",
	ResetEvent => "log_reset",
	 ErrorEvent => "log_error",
    );
    $heap->{services}->{$log_watcher->ID} = $service;
    $heap->{watchers}->{$log_watcher->ID} = $log_watcher;
  }
}

# Handle log resets the same way for each file.  Simply recognize that
# the log file was reset.
sub generic_log_reset {
  my ($heap, $wheel_id) = @_[HEAP, ARG0];
  my $service = $heap->{services}->{$wheel_id};
  print "--- $service log reset at ", scalar(gmtime), " GMT\n";
}

# Handle log errors the same way for each file.  Recognize that an
# error occurred while watching the file, and shut the watcher down.
# If this were a real log watcher, it would periodically try to resume
# watching the log file.
sub generic_log_error {
  my ($heap, $operation, $errno, $error_string, $wheel_id) =
    @_[HEAP, ARG0, ARG1, ARG2, ARG3];
  my $service = $heap->{services}->{$wheel_id};
  print "--- $service log $operation error $errno: $error_string\n";
  print "--- Shutting down $service log watcher.\n";
  delete $heap->{services}->{$wheel_id};
  delete $heap->{watchers}->{$wheel_id};
}

sub ossec_got_record {
  my $log_record = $_[ARG0];
  my $alertLevel;

  # Ok, we got a new OSSec alert, lets parse for a level of dangerous.
  if ($log_record =~ m/level (\d+)/ ) {
    if ($1 >= 11) {
      $alerts{ossec}{alert} = 1;
    }
  }
  return;
}

sub auth_got_record {
  my $log_record = $_[ARG0];
  my $user; 
  my $okUser;
  my $ok = 0;

  if ($log_record =~ m/session opened for user (\w+) /) {
    $user = $1;
#    print "New AuthLog line! For user $user\n";
    if (($log_record =~ m/cron:session/) && ($configH{logs}{auth}{ignorecron})) {
#      print "We're allowing this as we're ignoring cron\n"; 
      return 1;
    }
    foreach $okUser (@allowedUsers) {
      if ($okUser eq $user) {
        $ok = 1;
      }
    }
    if ($ok) {
#      print "User $user is in the allowed list, moving on\n";
      $ok = 0;
    } else { 
      # non allowed user logged in! Panic!
      $alerts{auth}{alert} = 1;
    }
  }
  return;
}

sub startsensors {
  my ($kernel, $heap) = @_[KERNEL, HEAP];

  $heap->{child} = POE::Wheel::Run->new(
    Program => sub { monitor_sensors() },
#    Conduit => 'pty-pipe',
    StdioFilter  => POE::Filter::Line->new(),    # Child speaks in lines.
    StderrFilter => POE::Filter::Line->new(),    # Child speaks in lines.
    StdoutEvent  => "got_child_stdout",          # Child wrote to STDOUT.
    StderrEvent  => "got_child_stderr",          # Child wrote to STDERR.
    CloseEvent   => "got_child_close",           # Child stopped writing.
  );
  $kernel->sig_child($heap->{child}->PID, "got_sigchld");
}

sub startudevadm {
  my ($kernel, $heap) = @_[KERNEL, HEAP];

  $heap->{child} = POE::Wheel::Run->new(
    Program => ["udevadm monitor"],    # Program to run.
    Conduit => 'pty-pipe',
    StdioFilter  => POE::Filter::Line->new(),    # Child speaks in lines.
    StderrFilter => POE::Filter::Line->new(),    # Child speaks in lines.
    StdoutEvent  => "got_child_stdout",          # Child wrote to STDOUT.
    StderrEvent  => "got_child_stderr",          # Child wrote to STDERR.
    CloseEvent   => "got_child_close",           # Child stopped writing.
  );
  $kernel->sig_child($heap->{child}->PID, "got_sigchld");
}

sub monitor_sensors {
  my $result;
  my @lines;
  my $line;
  my $sensor;
  my $temp;
  
  while (1) {  
    $result = `sensors -u`;
    @lines = split (/\n/, $result);
      foreach $line (@lines) {
        if ($line =~ /(temp\d*)_input: (\d*).\d*/) {
	  ($sensor, $temp) = ($1, $2);
          if ($temp <= $ALERTTEMP) {
            print "sensors,$sensor,$temp\n";
          }
        }
     }
     sleep 1;
   }
} 

# Deal with information the child wrote to its STDOUT.
sub got_child_stdout {
  my $stdout = $_[ARG0];
  my @values;

  if ($stdout =~ /,/) { 
    @values = split(/,/, $stdout);
    if ($values[0] eq "sensors") {
      $alerts{$values[1]}{alert} = 1;
    }
  }
#  print "STDOUT: $stdout\n";
}

# Deal with information the child wrote to its STDERR.  These are
# warnings and possibly error messages.
sub got_child_stderr {
  my $stderr = $_[ARG0];
  $stderr =~ tr[ -~][]cd;
  print "STDERR: $stderr\n";
}

# The child has closed its output filehandles.  It will not be sending
# us any more information, so destroy it.
sub got_child_close {
  my $heap = $_[HEAP];
  print "child closed.\n";
  delete $heap->{child};
}

# Handle SIGCHLD, otherwise the child process will not be reaped.
# Don't do anything significant, but do catch the signal so the child
# process is reaped.
sub got_sigchld {
  print "SIGCHLD reaped.\n";
}

sub getSystemEvents {
  my $key;
  my @results;

  foreach $key (%{$configH{systemevents}}) {
    if ($configH{systemevents}{$key}{enabled}) {
      push @results, $key;
    }
  }
  return @results;
}


sub getSystemUsers {

  my $fh;
  my @users;
  my @line;
  my $user;
  my $filename = "/etc/passwd";


  open($fh, '<', $filename) or die "Could not open file '$filename' $!";
  while (<$fh>) {
    @line = split(/:/, $_);
    if ($line[2] < 1000)  {
      push @users, $line[0];
    }
  }
  return @users;
}

sub getAllowedUsers {
  my @allowed;

  @allowed = split(/,/, $configH{logs}{auth}{allowedusers});
  if ($configH{logs}{auth}{allowsystemusers}) {
    @allowed = (@allowed, @systemUsers);
  }
  return @allowed;
}

### EOF ###
